<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Classic Snake</title>
    <style>
      :root {
        --bg: #0f1115;
        --panel: #171a21;
        --text: #e6e6e6;
        --muted: #9aa4b2;
        --accent: #47d147;
        --food: #ff4d4d;
        --grid: #222836;
        --border: #2a3142;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Trebuchet MS", "Lucida Sans Unicode", "Lucida Grande",
          "Lucida Sans", Arial, sans-serif;
        background: var(--bg);
        color: var(--text);
        min-height: 100vh;
        display: grid;
        place-items: center;
      }

      .wrap {
        width: min(92vw, 560px);
        display: grid;
        gap: 12px;
      }

      .panel {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 14px;
      }

      .row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        flex-wrap: wrap;
      }

      .score {
        font-size: 1rem;
        letter-spacing: 0.04em;
      }

      .status {
        font-size: 0.9rem;
        color: var(--muted);
      }

      canvas {
        width: 100%;
        height: auto;
        display: block;
        background: #10131a;
        border-radius: 12px;
        border: 1px solid var(--border);
        image-rendering: pixelated;
      }

      button {
        background: #232939;
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 8px 12px;
        font-size: 0.9rem;
        cursor: pointer;
      }

      button:hover {
        border-color: #3a4359;
      }

      .controls {
        display: none;
        gap: 8px;
      }

      .dpad {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 6px;
        max-width: 180px;
      }

      .dpad button {
        width: 100%;
      }

      .dpad .empty {
        visibility: hidden;
      }

      .hint {
        font-size: 0.85rem;
        color: var(--muted);
        line-height: 1.4;
      }

      @media (max-width: 640px) {
        .controls {
          display: grid;
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <main class="wrap">
      <section class="panel row">
        <div class="score">Score: <span id="score">0</span></div>
        <div class="status" id="status">Running</div>
        <div class="row">
          <button id="toggle">Pause</button>
          <button id="restart">Restart</button>
        </div>
      </section>

      <canvas id="board" width="480" height="480" aria-label="Snake board"></canvas>

      <section class="panel controls">
        <div class="dpad">
          <div class="empty"></div>
          <button data-dir="up">Up</button>
          <div class="empty"></div>
          <button data-dir="left">Left</button>
          <button data-dir="down">Down</button>
          <button data-dir="right">Right</button>
        </div>
        <div class="hint">
          Controls: Arrow keys or WASD. Space to pause. R to restart.
        </div>
      </section>
    </main>

    <script>
      const GRID_SIZE = 20;
      const CELL_SIZE = 24;
      const TICK_MS = 120;

      const board = document.getElementById("board");
      const ctx = board.getContext("2d");
      const scoreEl = document.getElementById("score");
      const statusEl = document.getElementById("status");
      const restartBtn = document.getElementById("restart");
      const toggleBtn = document.getElementById("toggle");

      board.width = GRID_SIZE * CELL_SIZE;
      board.height = GRID_SIZE * CELL_SIZE;

      function createRng(seed) {
        let s = seed >>> 0;
        return () => {
          s = (s * 1664525 + 1013904223) >>> 0;
          return s / 4294967296;
        };
      }

      function createInitialState(rng) {
        const mid = Math.floor(GRID_SIZE / 2);
        const snake = [
          { x: mid, y: mid },
          { x: mid - 1, y: mid },
          { x: mid - 2, y: mid },
        ];
        const state = {
          snake,
          dir: { x: 1, y: 0 },
          nextDir: { x: 1, y: 0 },
          food: null,
          score: 0,
          status: "running",
        };
        state.food = placeFood(state.snake, rng);
        return state;
      }

      function getEmptyCells(snake) {
        const occupied = new Set(snake.map((p) => `${p.x},${p.y}`));
        const cells = [];
        for (let y = 0; y < GRID_SIZE; y += 1) {
          for (let x = 0; x < GRID_SIZE; x += 1) {
            if (!occupied.has(`${x},${y}`)) {
              cells.push({ x, y });
            }
          }
        }
        return cells;
      }

      function placeFood(snake, rng) {
        const empties = getEmptyCells(snake);
        if (empties.length === 0) {
          return null;
        }
        const index = Math.floor(rng() * empties.length);
        return empties[index];
      }

      function isOpposite(a, b) {
        return a.x + b.x === 0 && a.y + b.y === 0;
      }

      function step(state, rng) {
        if (state.status !== "running") {
          return state;
        }

        const dir = state.nextDir;
        const head = state.snake[0];
        const nextHead = { x: head.x + dir.x, y: head.y + dir.y };

        if (
          nextHead.x < 0 ||
          nextHead.x >= GRID_SIZE ||
          nextHead.y < 0 ||
          nextHead.y >= GRID_SIZE
        ) {
          return { ...state, status: "gameover" };
        }

        const hitsSelf = state.snake.some(
          (segment) => segment.x === nextHead.x && segment.y === nextHead.y
        );
        if (hitsSelf) {
          return { ...state, status: "gameover" };
        }

        let nextSnake = [nextHead, ...state.snake];
        let nextFood = state.food;
        let nextScore = state.score;

        if (state.food && nextHead.x === state.food.x && nextHead.y === state.food.y) {
          nextScore += 1;
          nextFood = placeFood(nextSnake, rng);
          if (!nextFood) {
            return {
              ...state,
              snake: nextSnake,
              dir,
              nextDir: dir,
              food: null,
              score: nextScore,
              status: "won",
            };
          }
        } else {
          nextSnake = nextSnake.slice(0, -1);
        }

        return {
          ...state,
          snake: nextSnake,
          dir,
          nextDir: dir,
          food: nextFood,
          score: nextScore,
        };
      }

      function render(state) {
        ctx.fillStyle = "#10131a";
        ctx.fillRect(0, 0, board.width, board.height);

        ctx.strokeStyle = "#1b2130";
        ctx.lineWidth = 1;
        for (let i = 0; i <= GRID_SIZE; i += 1) {
          const pos = i * CELL_SIZE;
          ctx.beginPath();
          ctx.moveTo(pos, 0);
          ctx.lineTo(pos, board.height);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, pos);
          ctx.lineTo(board.width, pos);
          ctx.stroke();
        }

        if (state.food) {
          ctx.fillStyle = "#ff4d4d";
          ctx.fillRect(
            state.food.x * CELL_SIZE + 2,
            state.food.y * CELL_SIZE + 2,
            CELL_SIZE - 4,
            CELL_SIZE - 4
          );
        }

        ctx.fillStyle = "#47d147";
        state.snake.forEach((segment, index) => {
          const inset = index === 0 ? 1 : 3;
          ctx.fillRect(
            segment.x * CELL_SIZE + inset,
            segment.y * CELL_SIZE + inset,
            CELL_SIZE - inset * 2,
            CELL_SIZE - inset * 2
          );
        });

        scoreEl.textContent = String(state.score);
        if (state.status === "running") {
          statusEl.textContent = "Running";
        } else if (state.status === "paused") {
          statusEl.textContent = "Paused";
        } else if (state.status === "won") {
          statusEl.textContent = "You Win!";
        } else {
          statusEl.textContent = "Game Over";
        }
      }

      let rng = createRng(Date.now());
      let state = createInitialState(rng);

      function resetGame() {
        rng = createRng(Date.now());
        state = createInitialState(rng);
        render(state);
      }

      function togglePause() {
        if (state.status === "running") {
          state = { ...state, status: "paused" };
          toggleBtn.textContent = "Resume";
        } else if (state.status === "paused") {
          state = { ...state, status: "running" };
          toggleBtn.textContent = "Pause";
        }
        render(state);
      }

      function setDirection(next) {
        if (state.status === "gameover" || state.status === "won") {
          return;
        }
        if (!isOpposite(state.dir, next)) {
          state = { ...state, nextDir: next };
        }
      }

      function tick() {
        if (state.status !== "running") {
          return;
        }
        state = step(state, rng);
        if (state.status === "gameover" || state.status === "won") {
          toggleBtn.textContent = "Pause";
        }
        render(state);
      }

      const keyMap = {
        ArrowUp: { x: 0, y: -1 },
        ArrowDown: { x: 0, y: 1 },
        ArrowLeft: { x: -1, y: 0 },
        ArrowRight: { x: 1, y: 0 },
        w: { x: 0, y: -1 },
        s: { x: 0, y: 1 },
        a: { x: -1, y: 0 },
        d: { x: 1, y: 0 },
      };

      window.addEventListener("keydown", (event) => {
        const dir = keyMap[event.key];
        if (dir) {
          event.preventDefault();
          setDirection(dir);
          return;
        }
        if (event.key === " " || event.key === "p" || event.key === "P") {
          event.preventDefault();
          togglePause();
        } else if (event.key === "r" || event.key === "R") {
          event.preventDefault();
          resetGame();
        }
      });

      document.querySelectorAll("[data-dir]").forEach((button) => {
        button.addEventListener("pointerdown", () => {
          const dir = button.getAttribute("data-dir");
          if (dir === "up") setDirection({ x: 0, y: -1 });
          if (dir === "down") setDirection({ x: 0, y: 1 });
          if (dir === "left") setDirection({ x: -1, y: 0 });
          if (dir === "right") setDirection({ x: 1, y: 0 });
        });
      });

      restartBtn.addEventListener("click", resetGame);
      toggleBtn.addEventListener("click", togglePause);

      render(state);
      setInterval(tick, TICK_MS);
    </script>
  </body>
</html>
